Singleton

	单例对象保证在一个JVM中，只有一个实例存在
	
	优点：对于某些复杂类创建对象繁琐，节省系统开销；
		  省略new操作符，降低系统内存使用频率；
		  保证核心类可以单独控制整个流程。
		  
	
	单例模式确保某个类只有一个实例，且自行实例化并向整个系统提供这个实例。
	
	在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。
	
	这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。
	
	
	单例模式创建步骤：
	
			1、将默认的构造器私有化；
			
			2、在类中定义一个当前类的类型的静态属性，并创建该当前类的对象；
			
			3、提供一个 静态的类方法 来使用并返回这个 当前类 的 静态属性的对象；
			
			
			
	/**
	 * 懒汉方法
	 * 事实上，Java反射机制也可实例化 private的构造方法
	 */
	class Singleton {

		//因不能在类外部创建对象访问该类方法，所以需要加static
		/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */
		private static Singleton singleton;

		/*构造器私有化        --避免了类在外部被实例化*/
		private Singleton(){}

		//提供一个公共的方法返回类内部创建的对象
		public static Singleton getSingleton() {
			if (singleton == null) {
				singleton = new Singleton();
			}
			return singleton;
		}

	}
	
	/**
	 * 饿汉方法
	 * 饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的
	 */
	class Singleton {

		//因不能在类外部创建对象访问该类方法，所以需要加static
		/* 持有私有静态实例，防止被引用 */
		private static Singleton singleton = new Singleton();

		/*构造器私有化        --避免了类在外部被实例化*/
		private Singleton(){}

		//提供一个公共的方法返回类内部创建的对象
		public static Singleton getSingleton() {
			return singleton;
		}

	}
	
	懒汉、饿汉区别：
	
		1、饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题。懒汉式本身是非线程安全的；
		
		2、在资源加载和性能方面：饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。
								 懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了
								 
	懒汉处理线程安全问题：
	
			1、在 getSingleton 方法上加同步：public static synchronized Singleton getInstance()
			
			2、双重检查锁定；
			
			3、静态内部类