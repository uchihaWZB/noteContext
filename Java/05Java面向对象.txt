Java面向对象编程

	机器语言、汇编语言	面向机器
	C语言				面向过程
	Java语言			面向对象
	
	面向对象以功能来划分，而不是步骤。它的思想是 抽取一类具有相同属性和行为的事物。Java体系中“万物皆对象”（除了8种基本数据类型）

	1、抽象：把一类事物共有的[属性]和[行为]提取出来，形成一物理模板
	
	2、封装(访问控制修饰符，修饰 类、方法、属性)：	将抽象出的数据和对数据的操作封装在一起。目的 提高数据安全性，设置控制访问权限。
								数据保护在内部，其他程序只可通过被授权的操作(成员方法)才能对数据进行操作。
				
			公开级别：			public
			受保护级别：		protected	对子类和同一包中类公开
			默认级别(友好)：	无修饰符	对同一包中类公开
			私有级别：			private		只对类本身公开
			
			包：
				
			

	3、继承：通过已有类创建新类的机制，子类可以继承父类的属性和功能。提高代码复用性
	
			特点：1、子类除继承了父类的共同属性和方法外，子类还可有自己的属性和方法；
				  2、父类更通用，子类更具体；
				  3、同一包中，子类可获得父类除[private]的属性和方法，非同一包中，子类只能获得父类[public]和[protected]的属性和方法；
				  4、Java中仅支持单继承（子类只能有一个父类）；
				  
		class 子类 extends 父类 {
			
		}	
		
			super：子类中想要使用被子类隐藏的父类的(离子类最近的)成员变量或方法，使用super关键字
									
					继承中构造器问题：先调用父类的构造方法--->按声明顺序调用成员的初始化方法--->调用自身构造方法
					
					***每个子类中的构造方法中，如果没有显示的使用super去调用父类的某个构造方法，则默认使用super()，即调用父类不带参构造方法。
					   如果父类没有这个无参构造函数，编译报错。所以，当 父类中定义了多个构造方法时，应该包括一个不带参的构造方法（否则会被覆盖）；
					
					***子类主动调用父类带参构造函数，就不会调用默认无参构造函数；
					
					***super必须放在构造方法中第一行
					
					默认情况下单独使用对象的属性都会隐藏了 this.
					我们可以使用super和this来区分父类和子类中同名的属性和方法
					
			this和super：
			
					1、super：调用父类的某一构造函数，this：调用本类中的构造函数。调用构造函数时均需放在第一行，且不可同时出现在一个构造函数中；
			
					2、super引用当前对象直接父类中的成员，this代表当前对象名；
					
					3、this和super都指的是对象，所以不能在static中使用；
					
			方法的重写：
			
					子类继承父类时，子类的方法和父类的方法相同（除了方法体外）
					
					***重载和重写的区别：
					
								重载在同一类中，同方法名，不同参数类型或个数，目的是为了节省类中命名资源和提高代码可持续性。
								重写在父子类中，只有方法体不同，产生原因是 父类中的方法满足不了子类的需求。
								
								
			对象的上下转型：
			
				向上转型：子类引用的对象转换为父类类型，即子类创建一个对象，对象的引用放在父类的对象中。（此处父类对象可以是接口）
				
						  上转型对象不能操作子类[新增]的属性和方法。可以访问子类继承的成员变量和方法 或 重写的方法
						  
						  类比：哺乳动物是父类，老虎是子类。说 老虎是哺乳动物。老虎就会是去老虎本身独有的属性和行为
				
				向下转型：父类引用的对象转换为子类类型
								
								
			final：
			
				final修饰类，该类不能被继承；
				final修饰方法，该方法不能被重写；
				final修饰变量，即变为常量。声明常量时必须指定该常量的值，且不会再改变
				
				
	4、抽象类

			一个类中包含1或N个抽象方法，即为抽象类。抽象类是为了继承而存在的。
			
			抽象方法：只可以声明，不允许实现
			
			PS：
				抽象类不可以用new创建对象，即不可实例化；
				
				抽象类的子类：
							 是抽象类，可重写父类抽象类方法，也可继承父类抽象类方法
							 是非抽象类，必须重写实现(给出方法体)父类抽象类方法
				
				抽象类中可以没有抽象方法；
				
				抽象类的抽象方法不能和 private,final,static 共存
				
	5、接口：
	
			克服一个类只能有一个父类的缺点，一个类可实现多个接口；
			接口中全部都是抽象方法，且只允许用public修饰；
			实现接口必须实现接口中所有的抽象方法；
			接口可以继承接口（多继承、多实现1.6以上）；
			接口中 public final static 定义常量
			
			接口定义：interface 接口名；		实现接口：class 类名 implements 接口名
			
			接口主要用来定义标准
			
			接口和抽象类区别：
			
				接口的所有方法都是抽象的，抽象类的方法可以是抽象的也可是不抽象的；
				二者均不可实例化，接口需类来实现后再实例化类，抽象类需要类来继承后再实例化子类；
				抽象类只能单继承，接口可以多继承（jdk1.7）和多实现；
				接口的属性默认是 static final，抽象类种属性同普通类；
				接口中方法默认抽象的不需加abstract，抽象类中抽象的方法需加abstract。
				
	6、内部类：
	
			简单说就是 在一个类内部定义的类，注意：内部类不能直接创建，应为 外部类.内部类 变量名 = new 外部类对象.内部类对象
			
			1、常规内部类	（也可以说是成员内部类）
			
					作为外部类的一个成员，常规内部类中的方法可以直接使用外部类的实例变量和实例方法（即使是private的），不用生成外部类对象！！;
					
							因为创建某个 外部类的内部类对象时，内部类对象必会捕获一个指向外部类对象的引用
					
					外部类 想要访问 内部类 的成员属性和方法，就必须通过内部类的实例进行访问
					
				***要注意的问题：成员内部类中不可有 static 的变量和方法
								
					原因：首先明确两点，1、内部类的创建是依赖于外部类的。一般顺序为：加载外部类，实例化外部类对象-->根据外部类对象实例化内部类对象-->分配内部类(非static)成员空间
										
										2、	static修饰的成员会在类实例化前就被加载、分配空间，即外部类实例化前就加载了内部类的static成员，此时，内部类还未被加载，有冲突。
				class Outer {
					private static String info = "hello";

					class Inner {
						public void show() {
							System.out.println(info);
						}
					}
				}

				public class Demo {
					public static void main(String[] args) {
						Outer.Inner inner = new Outer().new Inner();
						inner.show();
					}
				}
			
			2、静态内部类（嵌套类）
			
					静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有
					
					所以 静态内部类的创建不需要依赖外部类（可以直接new出内部类对象，通过类名访问static，生不生成外部类对象都可），静态内部类不能使用任何非static的成员
					
					class Out {
						private static int age = 12;
						 
						static class In {
							public void print() {
								System.out.println(age);
							}
						}
					}
					 
					public class Demo {
						public static void main(String[] args) {
							Out.In in = new Out.In();
							in.print();
						}
					}
					
			3、匿名类
			
					1、匿名类没有访问修饰符；
					2、new匿名内部类时，这个类是要先存在的；
					3、匿名类是在接口和抽象类的应用上发展起来的，使用匿名类必须继承一个父类或实现一个接口；
					
				 ***4、匿名类 所在的方法中的形参 需要被内部类里面使用时，该形参需加 final
					
					说明：
						
						不使用匿名内部类来实现抽象方法和接口：
						
						抽象方法：																接口：
						
						abstract class A {															interface A { 
							public abstract void method();												public void method();
						}																			}
						
						class B extends A {															class B implements A {
							public void method() {														public void method() {
								实现方法;																	实现方法;
							}																			}
						}																			}
						
														//公共调用 抽象方法 和 实现接口方法
															public class Demo {
																public static void main(String[] args) {
																	B b = new B();
																	b.method();
																}
															}
						
						以上，B类继承了A类实现了method方法，B类实现了接口A也实现了method方法。但继承和实现接口的类如果只使用一次，就显得很麻烦
						
						所以用到匿名类：
						
						匿名内部类实现抽象方法：								    匿名内部类实现接口方法：
						
						abstract class A {															interface A { 
							public abstract void method();												public void method();
						}																			}
						
						
														//公共调用 抽象方法 和 实现接口方法
															public class Demo {
																public static void main(String[] args) {
																	
																	/**
																	* 接口不能实例化的，所以在new A()后有大括号，里面是实现接口内部的方法。
																	* 实际上就是指一个匿名类实现接口的方法。
																	*/
																	A a = new A() {
																		public void method() {
																			实现方法;
																		}
																	};
																	
																	a.method();
																}
															}
					
					结论：只要一个类是抽象的或是一个接口，其子类中的方法就可以使用匿名内部类进行实现。最常用：多线程，要继承 Thread类 或 Runnable接口
			
			